# `SimulationUI` 自定义下拉列表之三事件绑定
在上篇中编写了组件的结构并渲染插入到文档中。上篇回顾 [自定义组件编写-下拉列表之二结构渲染](https://github.com/loshafee/simulationUI/blob/master/doc/自定义组件编写-下拉列表之二结构渲染.md)，接下来将绑定组件的事件。

## `bindEvent` 事件绑定
- 回顾联想 `select` 下拉列表的表现及状态。点击下拉选项出现，事件处理函数如下：
      
      bindEvent: function () {
        var self = this
        // 创建事件
        var event = new CustomEvent("change", {"detail":{"select":true}})
        var ul = self.el.querySelector('ul')
        // 点击前先隐藏ul列表
        ul.style.display = 'none'
        // 给整个列表添加点击事件
        this.el.addEventListener('click', function (e) {
            var tagName = e.target.tagName
            if (tagName === "INPUT") {
                // 目标元素input
                // 判断ul列表的显隐
                ul.style.display = (ul.style.display === 'none' ? 'block' : 'none')
            } else if (tagName === 'LI') {
                // 目标元素li
                ul.style.display = 'none'
                if (self._prevItem === e.target) {
                    // 阻止重复点击
                    return
                }
                self._prevItem = e.target
                this.children[0].value = e.target.textContent
                self.value = e.target.dataset.id
                // 分发事件
                self.el.dispatchEvent(event)
            }
            // 阻止事件冒泡
            e.stopPropagation()
        }, false)
        ul.children[0].click() // 事件模拟
        document.addEventListener('click', function () {
            ul.style.display = 'none'
        }, false)
      }

    整个事件处理函数中，使用了事件委托，子元素的事件都会冒泡到共同的父元素中，通过事件目标 `e.target` 的元素名称获取目标对象。以此将 `li` 元素的文本内容 `textContent` 赋值到 `input` 中。并且初始模拟触发第一个 `li` 被点击 `ul.children[0].click()`。


